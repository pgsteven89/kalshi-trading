"""Base trading strategy interface and signal models."""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any

from kalshi_trading.clients.espn import GameState
from kalshi_trading.clients.models import Market, Position


class Signal(Enum):
    """Trading signal types."""

    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


@dataclass
class TradeSignal:
    """
    A trading signal generated by a strategy.

    This represents an actionable trade recommendation.
    """

    signal: Signal
    ticker: str
    side: str  # "yes" or "no"
    size: int  # Number of contracts
    price: int | None = None  # Limit price in cents, None for market order
    reason: str = ""  # Human-readable explanation
    timestamp: datetime = field(default_factory=datetime.now)

    @property
    def is_actionable(self) -> bool:
        """Check if this signal requires action (not HOLD)."""
        return self.signal != Signal.HOLD


@dataclass
class MarketState:
    """
    Current state of a Kalshi market.

    Wraps the Market model with additional derived properties.
    """

    market: Market

    @property
    def ticker(self) -> str:
        return self.market.ticker

    @property
    def yes_bid(self) -> int:
        return self.market.yes_bid

    @property
    def yes_ask(self) -> int:
        return self.market.yes_ask

    @property
    def no_bid(self) -> int:
        return self.market.no_bid

    @property
    def no_ask(self) -> int:
        return self.market.no_ask

    @property
    def spread(self) -> int:
        """Spread between yes bid and ask."""
        return self.market.yes_ask - self.market.yes_bid

    @property
    def is_open(self) -> bool:
        """Check if market is open for trading."""
        return self.market.status.value == "open"


class TradingStrategy(ABC):
    """
    Abstract base class for trading strategies.

    All strategies must implement the evaluate() method which takes
    game state, market state, and current position, and returns
    a trade signal (or None if no action needed).

    Example:
        class MyStrategy(TradingStrategy):
            def evaluate(self, game, market, position):
                if game.margin > 7 and game.period >= 4:
                    return TradeSignal(
                        signal=Signal.BUY,
                        ticker=market.ticker,
                        side="yes",
                        size=10,
                        reason="Large lead in 4th quarter"
                    )
                return None
    """

    def __init__(self, name: str, config: dict[str, Any] | None = None):
        """
        Initialize strategy.

        Args:
            name: Unique strategy name
            config: Strategy configuration parameters
        """
        self.name = name
        self.config = config or {}
        self._validate_config()

    def _validate_config(self) -> None:
        """
        Validate configuration.

        Override in subclasses to add validation logic.
        Raises ValueError if config is invalid.
        """
        pass

    @abstractmethod
    def evaluate(
        self,
        game_state: GameState,
        market_state: MarketState,
        position: Position | None,
    ) -> TradeSignal | None:
        """
        Evaluate current state and generate a trade signal.

        Args:
            game_state: Current game state from ESPN
            market_state: Current market state from Kalshi
            position: Current position in this market (None if no position)

        Returns:
            TradeSignal if action should be taken, None otherwise
        """
        pass

    def should_exit(
        self,
        game_state: GameState,
        market_state: MarketState,
        position: Position,
    ) -> TradeSignal | None:
        """
        Check if an existing position should be exited.

        Override in subclasses for custom exit logic.
        Default implementation returns None (no exit).

        Args:
            game_state: Current game state
            market_state: Current market state
            position: Current position to evaluate

        Returns:
            TradeSignal to exit, or None to hold
        """
        return None

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(name={self.name!r})"
